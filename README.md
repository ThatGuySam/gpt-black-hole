### Black Hole WebGPU Demo
### Generated by AI — GPT-5

This project renders a simple, real‑time black
hole using WebGPU in a single page app. It uses
ray‑marching in a fragment shader to approximate
gravitational lensing and an accretion disk.

- Entry file: `public/index.html`
- No build step: any static server works

### Features

- **WebGPU rendering**: device/adapter setup,
  canvas configuration with preferred format.
- **Full‑screen triangle**: procedural vertex
  shader eliminates vertex buffers.
- **Fragment ray‑marching**: bends rays toward
  the origin with a simple inverse‑square law
  to mimic lensing; clamps steps for perf.
- **Accretion disk**: thin ring test in the XZ
  plane with adjustable inner/outer radii and
  half‑thickness.
- **Camera uniforms**: resolution and camera
  basis (`camPos`, `camRight`, `camUp`,
  `camForward`) passed via a uniform buffer.
- **Interactive controls**:
  - Mouse hover to steer yaw/pitch
  - Horizontal hover adds roll (banking)
  - Wheel/trackpad zoom
  - Touch: 1‑finger drag (yaw/pitch), 2‑finger
    pinch (zoom), 2‑finger rotate (roll)
- **Responsive canvas**: CSS `aspect-ratio`,
  DPR‑aware backbuffer sizing, `ResizeObserver`
  and orientation change handling.

### How it works (high level)

1) A single render pass draws a full‑screen
   triangle. The vertex shader emits 3 NDC
   positions that cover the canvas.

2) The fragment shader builds a camera ray from
   basis vectors stored in uniforms, then steps
   the ray forward. Each step slightly turns the
   direction toward the origin. Early exits:
   - Inside event horizon → black
   - Beyond `MAX_DIST` → background tint
   - Within disk slab/ring → orange color

3) A small JS camera system computes basis
   vectors from yaw/pitch/roll and distance,
   writes them into a tightly packed 80‑byte
   uniform buffer each frame.

### Techniques used

- WebGPU setup, pipeline with `layout: "auto"`
- WGSL shaders (vertex + fragment)
- Uniform buffers (`@group(0) @binding(0)`)
- Full‑screen triangle pattern
- Ray‑marching with capped iterations
- Responsive backbuffer sized from CSS client
  size × `devicePixelRatio` (capped)
- Input handling for mouse and touch gestures

### Controls

- **Mouse**:
  - Move over canvas: yaw/pitch
  - Horizontal move: adds roll (banking)
  - Wheel/trackpad: zoom

- **Touch**:
  - 1 finger drag: yaw/pitch
  - 2 finger pinch: zoom
  - 2 finger rotate: roll

### Configure

Tweak constants in `public/index.html`:

- Shader: `Rs`, `MASS_K`, `STEP_S`, `STEPS`,
  `MAX_DIST`, `diskInner`, `diskOuter`,
  `diskHalfThk`
- Camera: initial `yaw`, `pitch`, `distance`
- Controls: `ROT_SPEED_YAW`, `ROT_SPEED_PITCH`,
  `MAX_ROLL`, `ROLL_RESP`
- Responsiveness: change CSS `aspect-ratio` or
  max‑height to fit your layout.

### Run locally

Requires a secure context. Use localhost or
HTTPS. Example with Python:

```bash
cd gpt-black-hole
python3 -m http.server 5173
```

Open `http://localhost:5173/public/` (or your
host’s served path to `public/index.html`).

### Browser support

Use an up‑to‑date Chromium with WebGPU enabled
(Chrome/Edge 113+). WebGPU must run in a secure
context.

### References

- **WebGPU Codelab**: Your first WebGPU app
  (`https://codelabs.developers.google.com/
  your-first-webgpu-app`)
- **WebGPU Uniforms** (WebGPU Fundamentals)
  (`https://webgpufundamentals.org/webgpu/
  lessons/webgpu-uniforms.html`)
- **Black hole shader inspiration**
  (`https://github.com/bzk9x/blackhole`)
- **DPR & sizing notes** (MDN, WebGL best
  practices; presnap & device‑pixel box)
  (`https://developer.mozilla.org/en-US/docs/
  Web/API/WebGL_API/WebGL_best_practices`)

### Limitations & future ideas

- Physics is a heuristic; not a full GR
  geodesic integrator
- Background is a flat tint; sample a star
  texture to better show lensing
- Compute shader path could precompute rays
  or adapt step size for speed/quality
- UI toggles for disk on/off, mass, step size

---
This document was generated by AI (GPT‑5).

