<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1"
    >
    <title>
      Black Hole (WebGPU) â€” Generated by AI (GPT-5)
    </title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: #000;
        color: #ddd;
        font-family: system-ui, -apple-system,
          Segoe UI, Roboto, Ubuntu, Cantarell,
          Noto Sans, Arial, sans-serif;
      }
      .wrap {
        display: grid;
        place-items: center;
        height: 100%;
        padding: 8px;
        box-sizing: border-box;
        gap: 8px;
      }
      canvas {
        width: 800px;
        height: 600px;
        image-rendering: pixelated;
        border: 1px solid #222;
        border-radius: 6px;
        box-shadow: 0 2px 14px rgba(0,0,0,.6);
      }
      .note {
        font-size: 12px;
        opacity: .7;
        text-align: center;
        max-width: 56ch;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <canvas width="800" height="600"></canvas>
      <div class="note">
        Requires a browser with WebGPU enabled
        (Chrome/Edge 113+). Serve via HTTPS or
        localhost for a secure context.
      </div>
    </div>
    <script type="module">
      /**
       * Initialize WebGPU and render a single
       * black hole frame.
       * @returns {Promise<void>}
       */
      async function main() {
        const canvas = document.querySelector(
          'canvas'
        )

        // Assert WebGPU support early.
        if (!navigator.gpu) {
          alert(
            'WebGPU not supported in this ' +
            'browser.'
          )
          throw new Error(
            'WebGPU not available'
          )
        }

        // Request adapter and device.
        const adapter = await navigator.gpu
          .requestAdapter()
        if (!adapter) {
          throw new Error(
            'No GPU adapter found'
          )
        }
        const device = await adapter
          .requestDevice()

        // Configure canvas context.
        const context = canvas.getContext(
          'webgpu'
        )
        const format = navigator.gpu
          .getPreferredCanvasFormat()
        context.configure({
          device: device,
          format: format,
          alphaMode: 'opaque'
        })

        // WGSL shaders: full-screen triangle and
        // black hole ray-march fragment.
        const shaderCode = /* wgsl */ `
struct Uniforms {
  resolution: vec2<f32>,
  pad0: vec2<f32>,
  camPos: vec3<f32>,
  pad1: f32,
  camRight: vec3<f32>,
  pad2: f32,
  camUp: vec3<f32>,
  pad3: f32,
  camForward: vec3<f32>,
  pad4: f32,
}

@group(0) @binding(0)
var<uniform> u: Uniforms;

@vertex
fn vs_main(
  @builtin(vertex_index)
  VertexIndex: u32
) -> @builtin(position) vec4<f32> {
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -1.0),
    vec2<f32>( 3.0, -1.0),
    vec2<f32>(-1.0,  3.0)
  );
  let coords = pos[VertexIndex];
  return vec4<f32>(coords, 0.0, 1.0);
}

@fragment
fn fs_main(
  @builtin(position)
  fragCoord: vec4<f32>
) -> @location(0) vec4<f32> {
  let uv = fragCoord.xy / u.resolution;
  let ndc = uv * 2.0 - vec2<f32>(1.0, 1.0);
  let aspect = u.resolution.x /
               u.resolution.y;
  let screenPos = vec2<f32>(
    ndc.x * aspect, ndc.y
  );

  // Build ray from camera basis.
  var rayDir = normalize(
    screenPos.x * u.camRight +
    screenPos.y * u.camUp +
    u.camForward
  );
  var rayPos = u.camPos;

  let Rs: f32 = 0.28;
  let MASS_K: f32 = 1.5;
  let STEP_S: f32 = 0.03;
  let STEPS: i32 = 500;
  let MAX_DIST: f32 = 20.0;
  // Narrower disk ring and thickness so only
  // some rays intersect it.
  let diskInner: f32 = 1.1;
  let diskOuter: f32 = 1.8;
  let diskHalfThk: f32 = 0.02;

  var pixelColor = vec3<f32>(0.0, 0.0, 0.0);
  var hit = false;
  for (var i: i32 = 0; i < STEPS; i = i + 1) {
    let r = length(rayPos);
    if (r < Rs) {
      pixelColor = vec3<f32>(0.0, 0.0, 0.0);
      hit = true;
      break;
    }
    if (r > MAX_DIST) {
      pixelColor = vec3<f32>(0.1, 0.2, 0.3);
      hit = true;
      break;
    }

    let radial2 = rayPos.x*rayPos.x +
                  rayPos.z*rayPos.z;
    if (abs(rayPos.y) < diskHalfThk &&
        radial2 < diskOuter*diskOuter &&
        radial2 > diskInner*diskInner) {
      pixelColor = vec3<f32>(1.0, 0.6, 0.2);
      hit = true;
      break;
    }

    let gravity = MASS_K * (Rs * Rs) /
                  (r * r);
    rayDir = normalize(
      rayDir - gravity *
      normalize(rayPos) * STEP_S
    );
    rayPos = rayPos + rayDir * STEP_S;
  }

  return vec4<f32>(pixelColor, 1.0);
}
`

        // Create pipeline.
        const module = device.createShaderModule({
          code: shaderCode
        })
        const pipeline = device
          .createRenderPipeline({
            layout: 'auto',
            vertex: {
              module: module,
              entryPoint: 'vs_main'
            },
            fragment: {
              module: module,
              entryPoint: 'fs_main',
              targets: [{ format: format }]
            },
            primitive: { topology: 'triangle-list' }
          })

        // Uniform buffer (80 bytes) for all
        // camera + resolution uniforms.
        const uniformBuffer = device
          .createBuffer({
            size: 80,
            usage:
              GPUBufferUsage.UNIFORM |
              GPUBufferUsage.COPY_DST
          })

        // Camera state and helpers.
        let yaw = Math.PI // look toward +Z from -Z
        let pitch = 0.27  // a little above plane
        let distance = 3.0
        const target = [0, 0, 0]
        const worldUp = [0, 1, 0]

        function clamp(n, lo, hi) {
          return Math.max(lo, Math.min(hi, n))
        }

        function normalize3(v) {
          const [x, y, z] = v
          const m = Math.hypot(x, y, z) || 1
          return [x/m, y/m, z/m]
        }

        function cross(a, b) {
          return [
            a[1]*b[2]-a[2]*b[1],
            a[2]*b[0]-a[0]*b[2],
            a[0]*b[1]-a[1]*b[0]
          ]
        }

        function sub(a, b) {
          return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]
        }

        function add(a, b) {
          return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]
        }

        function mulN(v, s) {
          return [v[0]*s, v[1]*s, v[2]*s]
        }

        function computeCamera() {
          // Spherical position around origin.
          const cp = Math.cos(pitch)
          const sp = Math.sin(pitch)
          const cy = Math.cos(yaw)
          const sy = Math.sin(yaw)
          const pos = [
            distance * sy * cp,
            distance * sp,
            distance * cy * cp
          ]

          // Forward looks to origin.
          const forward = normalize3(
            mulN(pos, -1)
          )
          let right = normalize3(
            cross(forward, worldUp)
          )
          // Handle gimbal lock by nudging right.
          if (!isFinite(right[0])) right = [1,0,0]
          const up = normalize3(
            cross(right, forward)
          )

          return { pos, right, up, forward }
        }

        function writeUniforms() {
          const { pos, right, up, forward } =
            computeCamera()
          const res = [
            canvas.width * 1.0,
            canvas.height * 1.0
          ]
          // Pack to 20 floats (80 bytes):
          // resolution(2), pad(2),
          // camPos(3), pad, right(3), pad,
          // up(3), pad, forward(3), pad
          const u = new Float32Array(20)
          u.set(res, 0)
          // pad 2 floats at 2..3
          u.set(pos, 4)
          u.set(right, 8)
          u.set(up, 12)
          u.set(forward, 16)
          device.queue.writeBuffer(
            uniformBuffer, 0, u
          )
        }

        // Bind group for @group(0) entries.
        const bindGroup = device
          .createBindGroup({
            layout: pipeline
              .getBindGroupLayout(0),
            entries: [{
              binding: 0,
              resource: { buffer: uniformBuffer }
            }]
          })

        // Mouse-position based rotation (no drag).
        let hoverX = 0
        let hoverY = 0
        function updateHover(e){
          const r = canvas.getBoundingClientRect()
          const nx = (e.clientX - r.left) / r.width
          const ny = (e.clientY - r.top) / r.height
          hoverX = nx * 2 - 1
          hoverY = ny * 2 - 1
        }
        canvas.addEventListener('pointermove', updateHover)
        canvas.addEventListener('pointerenter', updateHover)
        canvas.addEventListener('pointerleave', () => {
          hoverX = 0
          hoverY = 0
        })

        canvas.addEventListener(
          'wheel', (e) => {
            e.preventDefault()
            const factor = Math.exp(e.deltaY*0.001)
            distance *= factor
            distance = clamp(distance, 1.2, 10)
          }, { passive: false }
        )

        // Resize handling (optional DPI aware).
        function resizeCanvas() {
          // Keep HTML size; ensure backing store
          // matches attributes for crispness.
          // Here we keep 800x600 attributes.
          writeUniforms()
        }
        window.addEventListener('resize', resizeCanvas)

        // Animation loop.
        let lastTs = performance.now()
        const ROT_SPEED_YAW = 1.8
        const ROT_SPEED_PITCH = 1.2
        function frame() {
          // Delta time in seconds (clamped)
          const now = performance.now()
          let dt = (now - lastTs) / 1000
          lastTs = now
          if (!isFinite(dt) || dt > 0.1) dt = 0.016

          // Rotate based on cursor offset from center
          // Positive hoverX moves right; invert for yaw
          yaw -= hoverX * ROT_SPEED_YAW * dt
          // Move up increases pitch
          pitch += hoverY * ROT_SPEED_PITCH * dt
          pitch = clamp(pitch, -1.3, 1.3)

          writeUniforms()
          const encoder = device
            .createCommandEncoder()
          const textureView = context
            .getCurrentTexture()
            .createView()
          const pass = encoder.beginRenderPass({
            colorAttachments: [{
              view: textureView,
              clearValue:
                { r: 0, g: 0, b: 0, a: 1 },
              loadOp: 'clear',
              storeOp: 'store'
            }]
          })
          pass.setPipeline(pipeline)
          pass.setBindGroup(0, bindGroup)
          pass.draw(3, 1, 0, 0)
          pass.end()
          const commandBuffer = encoder.finish()
          device.queue.submit([commandBuffer])
          requestAnimationFrame(frame)
        }
        frame()
      }

      // Kick things off.
      main().catch((error) => {
        console.error(error)
      })
    </script>
  </body>
  </html>


